import re

import yaml
import openpyxl
from openpyxl.cell.cell import MergedCell
import torch
import pandas as pd

from common.stats import STATS_LENGTH, Infusion
from common.model import Model, Team
from common.characters import CHAR_FACTORY
from common.weapon import WEAPON_FACTORY
from common.artifact import ArtifactSet, ARTIFACT_FACTORY
from common.enemy import ENEMY_FACTORY
from common import config


def team_generation(char_data):
    """
    This function will take data of characters, and form Weapon, ArtifactSet, Character objects for each character,
    and then create a Team object of the characters.

    :param char_data: the data of character that is generated by read_char_excel function

    :return: the created Team object
    """
    chars = []
    for data in char_data:
        artifact_set = ArtifactSet(data['artifact']['stats'],
                                   two_set=ARTIFACT_FACTORY[data['artifact']['two_set']],
                                   four_set=ARTIFACT_FACTORY[data['artifact']['four_set']])
        weapon = WEAPON_FACTORY[data['weapon']['name']](data['weapon']['affix'])
        character = CHAR_FACTORY[data['char']['name']](weapon=weapon,
                                                       artifact=artifact_set,
                                                       level=data['char']['level'],
                                                       constellation=data['char']['constellation'],
                                                       name=data['name'],
                                                       ascension_phase=data['char']['ascension_phase'],
                                                       skill_level=data['char']['skill_level'])
        chars.append(character)
    team = Team(*chars)
    return team


def read_char_excel(file_direc=r".\data\characters.xlsx"):
    """
    This function will read a xlsx file that stores information of characters and return the
    processed data of the characters

    :param file_direc: the directory of character xlsx file

    :return: processed character data that could be sent to team_generation function directly
    """
    ws = openpyxl.load_workbook(file_direc, data_only=True).worksheets[0]
    chars = []
    header = [config.stats_map[cell.value] for cell in ws[1]]
    data_map = config.stats_pos_map
    for row in ws.iter_rows(min_row=2):
        artifact_data = torch.zeros(STATS_LENGTH)
        char_data = {}
        for i, cell in enumerate(row):
            value = cell.value
            if i <= 8:
                '''
                the basic information of character
                '''
                char_data[header[i]] = value
            else:
                '''
                the attributes of artifacts of character
                '''
                value = 0. if value is None else float(value)
                artifact_data[data_map[header[i]]] = value

        level = char_data['character_level']
        if re.match(r"\d{1,}\+", level):
            level = int(level[:-1])
            ascension = (level >= torch.tensor([20, 40, 50, 60, 70, 80])).sum().item()
        else:
            level = int(level)
            ascension = (level > torch.tensor([20, 40, 50, 60, 70, 80])).sum().item()

        char_data = {'name': char_data['name'],
                     'char': {'name': config.char_map[char_data['character']],
                              'level': level,
                              'constellation': int(char_data['character_constellation']),
                              'ascension_phase': ascension,
                              'skill_level': tuple(int(i.strip()) for i in char_data['skill_level'].split(','))},
                     'weapon': {'name': config.weapon_map[char_data['weapon']],
                                'affix': int(char_data['weapon_affix'])},
                     'artifact': {'two_set': config.artifact_map[char_data['artifact_two']],
                                  'four_set': config.artifact_map[char_data['artifact_four']],
                                  'stats': artifact_data.reshape(1, STATS_LENGTH)}}
        # print(char_data['char']['skill_level'])
        chars.append(char_data)
    return chars


def read_enemy_excel(file_direc=r".\data\enemy.xlsx"):
    """
    This function will read xlsx file of enemy objects, and then return a list of Enemy objects

    :param file_direc: the directory of enemy xlsx file

    :return: list of processed Enemy objects
    """
    ws = openpyxl.load_workbook(file_direc, data_only=True).worksheets[0]
    enemies = {}
    header = [config.enemy_header_map[cell.value] for cell in ws[1]]
    for row in ws.iter_rows(min_row=2):
        enemy_data = {}
        for i, cell in enumerate(row):
            value = cell.value
            enemy_data[header[i]] = value
        enemies[enemy_data['name']] = ENEMY_FACTORY[config.enemy_map[enemy_data['enemy']]](enemy_data['enemy_level'])
    return enemies


def expand_params(params):
    """
    This function will take parameters that is sent from function value_parsing,
    and then check whether each parameter is keyword parameter.

    :param params: the parameters parsed by the value_parsing function

    :return: the arguments and keyword arguments
    """
    arg = []
    kwarg = {}
    for param in params:
        if "=" in param:
            k, v = param.split("=")
            kwarg[k] = v
        else:
            arg.append(param)
    return arg, kwarg


def value_parsing(char, values, mode):
    """
    This function will take a character and the value of the skill or buff cell.
    It'll first decode the value into name and parameters. If the value is calling weapon or
    artifact of a character, it'll send the corresponding skill/buff of them to the output.
    Otherwise, the value will be called on the skills/buffs of the character and then send
    the skill/buff to the output.

    :param char: Character object
    :param value: the value from a skill/buff cell
    :param mode: whether the value is a skill or a buff

    :return:
    """
    objects = []
    if mode in ['skills', 'skill']:
        d = char.skills
    elif mode in ['buffs', 'buff']:
        d = char.buffs
    else:
        raise ValueError
    # print(value)
    pattern = r"([a-zA-z0-9\u4e00-\u9fff]{1,})(?:{{0,1})([a-zA-z0-9\u4e00-\u9fff]{0,})(?:}{0,1})(?:\({0,1})([a-zA-z0-9\u4e00-\u9fff]{0,})(?:\){0,1})"

    for value in values.split():
        groups = re.match(pattern, value)
        name, params, reaction_name = groups
        reaction = config.reaction_map[reaction_name]
        params = [i.strip() for i in params.split(',')]
        if name in config.skill_map.keys():
            if config.skill_map[name] == 'weapon':
                if mode in ['skills', 'skill']:
                    target = char.weapon.skills
                elif mode in ['buffs', 'buff']:
                    target = char.weapon.buffs
                else:
                    raise ValueError

            elif config.skill_map[name] == 'artifact':
                if mode in ['skills', 'skill']:
                    target = char.artifact.skills
                elif mode in ['buffs', 'buff']:
                    target = char.artifact.buffs
                else:
                    raise ValueError
            else:
                raise

            if len(params) == 1 and params[0] == '':
                objects.append(target[0])
            else:
                arg, kwarg = expand_params(params[1:])
                obj = target[int(params[0])]
                obj.update(*arg, **kwarg)
                objects.append(obj)

        else:
            arg, kwarg = expand_params(params)
            # if value == "附魔":
            #     print(d[name])
            obj = d[name]
            obj.update(*arg, **kwarg)
            objects.append(obj)
    return objects


def read_skill_excel(team, file_direc=r".\data\skills.xlsx"):
    """
    This function will read xlsx file of skills.
    It'll create skill, buff, and infusion DataFrame object, and decode the value of skill/buff cell by
    value_parsing function, and add the value to the three DataFrame objects.

    :param team: Team object
    :param file_direc: directory of the xlsx skill file

    :return: skill, buff, and infusion DataFrame object
    """
    char_map = {char.name: char for char in team}
    skill_df = pd.DataFrame(columns=['skill', 'start_time', 'end_time', 'reaction', 'kwarg'])
    buff_df = pd.DataFrame(columns=['buff', 'start_time', 'end_time'])
    infusion_df = pd.DataFrame(columns=['infusion', 'start_time', 'end_time'])

    ws = openpyxl.load_workbook(file_direc, data_only=True).worksheets[0]

    time_row, on_field_row, skill_row, buff_row = None, None, None, None
    row_char_map = {}
    for i, cell in enumerate(ws['A'], 1):
        try:
            mark = config.skill_header_map[cell.value]
            if mark == 'time':
                time_row = i
            elif mark == 'on_field':
                on_field_row = i
            elif mark == 'skill':
                skill_row = i
            elif mark == 'buff':
                buff_row = i
            else:
                raise
        except KeyError:
            # print(i)
            row_char_map[i] = char_map[cell.value]

    times = [float(cell.value) for cell in ws[time_row][1:]]
    last = ws[on_field_row][0]
    on_field_indexes = []
    for i in range(1, len(times)):
        value = ws[on_field_row][i].value
        if value is None:
            on_field_indexes.append(char_map[last].idx)
        else:
            on_field_indexes.append(char_map[value].idx)
            last = value
    team.on_field = on_field_indexes
    # on_fields =
    # print(col_char_map)
    # print(buff_col)
    for idx, row in enumerate(ws.iter_rows(min_row=skill_row+1, max_row=buff_row-1), skill_row+1):
        # print(idx)
        char = row_char_map[idx]
        start = False
        i = 0
        for i, cell in enumerate(row[1:]):
            if i == len(times):
                break
            if isinstance(cell, MergedCell):
                pass
            else:
                if cell.value is None:
                    pass
                else:
                    if start:
                        end_time = times[i]
                        for skill in skills:
                            skill_df.loc[len(skill_df.index)] = [skill, start_time, end_time, None, {}]

                    start_time = times[i]
                    skills = value_parsing(char, cell.value, 'skills')
                    if len(skills) != 0:
                        start = True
                    else:
                        start = False
        if start:
            end_time = times[i]
            for skill in skills:
                skill_df.loc[len(skill_df.index)] = [skill, start_time, end_time, None, {}]

    for idx, row in enumerate(ws.iter_rows(min_row=buff_row + 1), buff_row + 1):
        # print(idx)
        char = row_char_map[idx]
        start = False
        i = 0
        for i, cell in enumerate(row[1:]):
            if i == len(times):
                pass
            if isinstance(cell, MergedCell):
                pass
            else:
                if cell.value is None:
                    pass
                else:
                    if start:
                        end_time = times[i]
                        for buff in buffs:
                            if isinstance(buff, Infusion):
                                infusion_df.loc[len(infusion_df.index)] = [buff, start_time, end_time]
                            else:
                                buff_df.loc[len(buff_df.index)] = [buff, start_time, end_time]

                    start_time = times[i]
                    buffs = value_parsing(char, cell.value, 'buffs')
                    if len(buffs) != 0:
                        start = True
                    else:
                        start = False
        if start:
            end_time = times[i]
            for buff in buffs:
                if isinstance(buff, Infusion):
                    infusion_df.loc[len(infusion_df.index)] = [buff, start_time, end_time]
                else:
                    buff_df.loc[len(buff_df.index)] = [buff, start_time, end_time]

    return skill_df, buff_df, infusion_df
