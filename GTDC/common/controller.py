import re
import copy

import yaml
import openpyxl
from openpyxl.cell.cell import MergedCell
from openpyxl.utils.exceptions import InvalidFileException
import torch
import pandas as pd

from GTDC.common import config
from GTDC.common.reactions.reaction import REACTION_FACTORY
from GTDC.common.exception import InvalidCell, InvalidTitle, InvalidStats, InvalidCharNameInSkillFile, InvalidIndex
from GTDC.common.exception import MissingTime, MissingSkills, MissingBuffs, MissingOnField
from GTDC.common.exception import invalid_char_file, varify_char_file, invalid_enemy_file, varify_enemy_file
from GTDC.common.exception import invalid_skill_index, invalid_skill_file, varify_skill_file
from GTDC.common.stats import STATS_LENGTH, Infusion
from GTDC.common.model import Model, Team
from GTDC.common.characters import CHAR_FACTORY
from GTDC.common.weapon import WEAPON_FACTORY
from GTDC.common.artifact import ArtifactSet, ARTIFACT_FACTORY
from GTDC.common.enemy import ENEMY_FACTORY


def team_generation(char_data):
    """
    This function will take data of characters, and form Weapon, ArtifactSet, Character objects for each character,
    and then create a Team object of the characters.

    :param char_data: the data of character that is generated by read_char_excel function

    :return: the created Team object
    """
    chars = []
    for data in char_data:
        artifact_set = ArtifactSet(data['artifact']['stats'],
                                   two_set=ARTIFACT_FACTORY[data['artifact']['two_set']],
                                   four_set=ARTIFACT_FACTORY[data['artifact']['four_set']])
        weapon = WEAPON_FACTORY[data['weapon']['name']](data['weapon']['affix'])
        character = CHAR_FACTORY[data['char']['name']](weapon=weapon,
                                                       artifact=artifact_set,
                                                       level=data['char']['level'],
                                                       constellation=data['char']['constellation'],
                                                       name=data['name'],
                                                       ascension_phase=data['char']['ascension_phase'],
                                                       skill_level=data['char']['skill_level'])
        chars.append(character)
    team = Team(*chars)
    return team


def read_char_excel(file_direc=r".\data\characters.xlsx"):
    """
    This function will read a xlsx file that stores information of characters and return the
    processed data of the characters

    :param file_direc: the directory of character xlsx file

    :return: processed character data that could be sent to team_generation function directly
    """
    ws = openpyxl.load_workbook(file_direc, data_only=True).worksheets[0]
    chars = []
    header = []

    for cell in ws[1]:
        try:
            header.append(config.stats_map[cell.value])
        except KeyError:
            raise InvalidTitle(cell)

    data_map = config.stats_pos_map
    for row in ws.iter_rows(min_row=2):
        artifact_data = torch.zeros(STATS_LENGTH)
        char_data = {}
        for i, cell in enumerate(row):
            value = cell.value
            if i <= 8:
                '''
                the basic information of character
                '''
                varify_char_file(header[i], cell)
                char_data[header[i]] = value
            else:
                '''
                the attributes of artifacts of character
                '''
                try:
                    value = 0. if value is None else float(value)
                except ValueError:
                    raise InvalidStats(cell)
                artifact_data[data_map[header[i]]] = value

        level = char_data['character_level']
        if re.match(r"\d{1,}\+", level):
            level = int(level[:-1])
            ascension = (level >= torch.tensor([20, 40, 50, 60, 70, 80])).sum().item()
        else:
            level = int(level)
            ascension = (level > torch.tensor([20, 40, 50, 60, 70, 80])).sum().item()

        char_data = {'name': char_data['name'],
                     'char': {'name': config.char_map[char_data['character']],
                              'level': level,
                              'constellation': int(char_data['character_constellation']),
                              'ascension_phase': ascension,
                              'skill_level': tuple(int(i.strip()) for i in char_data['skill_level'].split(','))},
                     'weapon': {'name': config.weapon_map[char_data['weapon']],
                                'affix': int(char_data['weapon_affix'])},
                     'artifact': {'two_set': config.artifact_map[char_data['artifact_two']],
                                  'four_set': config.artifact_map[char_data['artifact_four']],
                                  'stats': artifact_data.reshape(1, STATS_LENGTH)}}
        chars.append(char_data)
    return chars


def read_enemy_excel(file_direc=r".\data\enemy.xlsx"):
    """
    This function will read xlsx file of enemy objects, and then return a list of Enemy objects

    :param file_direc: the directory of enemy xlsx file

    :return: list of processed Enemy objects
    """
    ws = openpyxl.load_workbook(file_direc, data_only=True).worksheets[0]
    enemies = {}
    header = [config.enemy_header_map[cell.value] for cell in ws[1]]
    for row in ws.iter_rows(min_row=2):
        enemy_data = {}
        for i, cell in enumerate(row):
            value = cell.value
            varify_enemy_file(header[i], cell)
            enemy_data[header[i]] = value
        enemies[enemy_data['name']] = ENEMY_FACTORY[config.enemy_map[enemy_data['enemy']]](enemy_data['enemy_level'])
    return enemies


def expand_params(params):
    """
    This function will take parameters that is sent from function value_parsing,
    and then check whether each parameter is keyword parameter.

    :param params: the parameters parsed by the value_parsing function

    :return: the arguments and keyword arguments
    """
    arg = []
    kwarg = {}
    for param in params:
        if "=" in param:
            k, v = param.split("=")
            kwarg[k] = v
        else:
            arg.append(param)
    return arg, kwarg


def value_parsing(char, values, mode):
    """
    This function will take a character and the value of the skill or buff cell.
    It'll first decode the value into name and parameters. If the value is calling weapon or
    artifact of a character, it'll send the corresponding skill/buff of them to the output.
    Otherwise, the value will be called on the skills/buffs of the character and then send
    the skill/buff to the output.

    :param char: Character object
    :param value: the value from a skill/buff cell
    :param mode: whether the value is a skill or a buff

    :return:
    """
    objects = []
    reaction = []
    if mode in ['skills', 'skill']:
        d = char.skills
    elif mode in ['buffs', 'buff']:
        d = char.buffs
    else:
        raise ValueError(f"Invalid mode {mode}")
    # print(value)
    pattern = r"([a-zA-z0-9\u4e00-\u9fff]{1,})(?:{{0,1})([a-zA-z0-9\u4e00-\u9fff\,]{0,})(?:}{0,1})(?:\({0,1})([a-zA-z0-9\u4e00-\u9fff\,\{\}]{0,})(?:\){0,1})"

    # print(values.split())

    for value in values.split():
        value = value.replace("（", "(").replace("）", ")").replace("，", ",")
        # print(value)
        groups = re.match(pattern, value).groups()
        name, params, reaction_aliases = groups
        # print(REACTION_FACTORY)

        reaction_aliases = reaction_aliases.split(',')
        # print(reaction_aliases)
        reaction_names = [config.reaction_map[alias] for alias in reaction_aliases]
        # print(reaction_names)
        reactions = [] if reaction_names[0] is None else [REACTION_FACTORY[reaction_name]() for reaction_name in reaction_names]

        params = [i.strip() for i in params.split(',')]
        # print(params)
        if name in config.skill_map.keys():
            if config.skill_map[name] == 'weapon':
                target = char.weapon
            elif config.skill_map[name] == 'artifact':
                target = char.artifact
            else:
                raise ValueError(f"Invalid mode {mode}")

            if mode in ['skills', 'skill']:
                target = target.skills
            elif mode in ['buffs', 'buff']:
                target = target.buffs
            else:
                raise ValueError(f"Invalid mode {mode}")

            if len(params) == 1 and params[0] == '':
                objects.append((target[0], reactions))
            else:
                # print(len(params))
                # print(value)
                arg, kwarg = expand_params(params[1:])
                # print(arg, kwarg)
                # print(name)
                obj = target[int(params[0])]
                obj.update(*arg, **kwarg)
                objects.append((obj, reactions))

        else:
            # print(name)
            arg, kwarg = expand_params(params)
            # if value == "附魔":
            #     print(d[name])
            obj = d[name]
            obj.update(*arg, **kwarg)
            objects.append((obj, reactions))
    # print()
    return objects


def decode_skill_block(block, times, row_char_map, data_frame, mode):
    for idx, row in block:
        # print(idx)
        char = row_char_map[idx]
        start = False
        i = 0
        for i, cell in enumerate(row[1:]):
            if i == len(times):
                break
            if isinstance(cell, MergedCell):
                pass
            else:
                if cell.value is None:
                    if start:
                        end_time = times[i]
                        write_df(data_frame, objects, start_time, end_time, mode)
                        start = False
                else:
                    if start:
                        end_time = times[i]
                        write_df(data_frame, objects, start_time, end_time, mode)
                    start_time = times[i]
                    objects = value_parsing(char, cell.value, mode)
                    if len(objects) != 0:
                        start = True
                    else:
                        start = False
        if start:
            end_time = times[i]
            write_df(data_frame, objects, start_time, end_time, mode)


def write_df(df, objects, start_time, end_time, mode):
    if mode == "skill" or mode == "skills":
        for obj, reactions in objects:
            df.loc[len(df.index)] = [obj, start_time, end_time, reactions, {}]
    elif mode == "buffs" or mode == "buff":
        for obj, _ in objects:
            if isinstance(obj, Infusion):
                df[1].loc[len(df[1].index)] = [obj, start_time, end_time]
            else:
                df[0].loc[len(df[0].index)] = [obj, start_time, end_time]
    else:
        raise ValueError(f"Invalid mode {mode}")


def read_skill_excel(team, ws, ws_idx=0):
    """
    This function will read xlsx file of skills.
    It'll create skill, buff, and infusion DataFrame object, and decode the value of skill/buff cell by
    value_parsing function, and add the value to the three DataFrame objects.

    :param team: Team object
    :param file_direc: directory of the xlsx skill file

    :return: skill, buff, and infusion DataFrame object
    """
    char_map = {char.name: char for char in team}
    skill_df = pd.DataFrame(columns=['skill', 'start_time', 'end_time', 'reaction', 'kwarg'])
    buff_df = pd.DataFrame(columns=['buff', 'start_time', 'end_time'])
    infusion_df = pd.DataFrame(columns=['infusion', 'start_time', 'end_time'])

    ws = ws[ws_idx]

    time_row, on_field_row, skill_row, buff_row, reaction_row = None, None, None, None, None
    row_char_map = {}

    #
    for i, cell in enumerate(ws['A'], 1):
        if cell.value in config.skill_header_map.keys():
            mark = config.skill_header_map[cell.value]
            if mark == 'time':
                time_row = i
            elif mark == 'on_field':
                on_field_row = i
            elif mark == 'skill':
                skill_row = i
            elif mark == 'buff':
                buff_row = i
            elif mark == 'reaction':
                reaction_row = i
        else:
            # print(i)
            if cell.value in char_map.keys():
                row_char_map[i] = char_map[cell.value]
            else:
                raise InvalidCharNameInSkillFile(cell, ws_idx)
    if time_row is None:
        raise MissingTime(ws_idx)
    if on_field_row is None:
        raise MissingOnField(ws_idx)
    if skill_row is None:
        raise MissingSkills(ws_idx)
    if buff_row is None:
        raise MissingBuffs(ws_idx)
    if reaction_row is None:
        reaction_row = buff_row

    times = [float(cell.value) for cell in ws[time_row][1:]]
    last = ws[on_field_row][0]
    on_field_indexes = []
    for i in range(1, len(times)):
        cell = ws[on_field_row][i]
        value = cell.value
        if value is None:
            on_field_indexes.append(char_map[last].idx)
        elif value in char_map.keys():
            on_field_indexes.append(char_map[value].idx)
            last = value
        else:
            InvalidCharNameInSkillFile(cell, ws_idx)
    team.on_field = on_field_indexes

    '''
    decoding skills sections
    '''
    skill_block = enumerate(ws.iter_rows(min_row=skill_row+1, max_row=reaction_row-1), skill_row+1)
    decode_skill_block(skill_block, times, row_char_map, skill_df, "skill")
    buff_block = enumerate(ws.iter_rows(min_row=buff_row + 1), buff_row + 1)
    decode_skill_block(buff_block, times, row_char_map, [buff_df, infusion_df], "buff")

    return skill_df, buff_df, infusion_df


def get_char():
    while True:
        directory = input("请输入角色信息表格位置：")
        if directory == '':
            directory = r"data\characters.xlsx"
        try:
            chars_data = read_char_excel(directory)
            return chars_data
        except InvalidCell as err:
            invalid_char_file(err)
            print("请重新输入")
            print()
        except InvalidFileException:
            print("文件无法识别，请检测是否能用Excel打开该文件")
            print()
        except FileNotFoundError as err:
            print("文件不存在，请重新输入")
            print()


def get_enemy():
    while True:
        directory = input("请输入敌人信息表格位置：")
        if directory == '':
            directory = r"data\enemy.xlsx"
        try:
            enemies = read_enemy_excel(directory)
            return enemies
        except InvalidCell as err:
            invalid_enemy_file(err)
            print("请重新输入")
            print()
        except InvalidFileException:
            print("文件无法识别，请检测是否能用Excel打开该文件")
            print()
        except FileNotFoundError as err:
            print("文件不存在，请重新输入")
            print()


def get_skills(enemies, chars_data):

    while True:
        directory = input("请输入技能信息表格位置：")
        if directory == '':
            directory = r"data\skills.xlsx"
        try:
            enemies_x_models = []
            workbook = openpyxl.load_workbook(directory, data_only=True)
            ws_names = workbook.sheetnames
            ws = workbook.worksheets
            enemy_names = []
            for enemy in enemies:
                enemy_names.append(enemy)
                models = []

                for ws_idx in range(len(ws)):
                    team = team_generation(copy.deepcopy(chars_data))
                    skill_df, buff_df, infusion_df = read_skill_excel(team, ws, ws_idx)
                    models.append(Model(team=team, enemy=enemies[enemy],
                                        skills=skill_df.copy(),
                                        buffs=buff_df.copy(),
                                        infusions=infusion_df.copy()))

                for model in models:
                    model.validation()

                enemies_x_models.append(models)

            return enemies_x_models, ws_names, enemy_names

        except InvalidIndex as err:
            invalid_skill_index(err)
            print("请重新输入")
            print()
        except InvalidCell as err:
            invalid_skill_file(err)
            print("请重新输入")
            print()
        except InvalidFileException:
            print("文件无法识别，请检测是否能用Excel打开该文件")
            print()
        except FileNotFoundError as err:
            print("文件不存在，请重新输入")
            print()


def terminal_ui():
    chars_data = get_char()
    enemies = get_enemy()
    # print(chars_data)

    enemies_x_models, ws_names, enemy_names = get_skills(enemies, chars_data)

    damage_result = []
    for models in enemies_x_models:
        damages = []
        for model in models:
            damages.append(model.run())
        damage_result.append(damages)

    return damage_result, enemies_x_models, ws_names, enemy_names